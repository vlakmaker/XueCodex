"use strict";(self.webpackChunkxuecodex=self.webpackChunkxuecodex||[]).push([[4703],{7181:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>d,frontMatter:()=>a,metadata:()=>r,toc:()=>h});const r=JSON.parse('{"id":"topics/ai-fundamentals/search-algorithms","title":"Search Algorithms in AI","description":"This knowledge item covers foundational search algorithms used in classical AI. These algorithms guide intelligent agents in navigating problem spaces, finding optimal paths, or making strategic decisions in games.","source":"@site/docs/topics/ai-fundamentals/search-algorithms.md","sourceDirName":"topics/ai-fundamentals","slug":"/topics/ai-fundamentals/search-algorithms","permalink":"/docs/topics/ai-fundamentals/search-algorithms","draft":false,"unlisted":false,"editUrl":"https://github.com/vlakmaker/XueCodex/tree/main/docs/topics/ai-fundamentals/search-algorithms.md","tags":[{"inline":true,"label":"ai-fundamentals","permalink":"/docs/tags/ai-fundamentals"},{"inline":true,"label":"search","permalink":"/docs/tags/search"},{"inline":true,"label":"planning","permalink":"/docs/tags/planning"},{"inline":true,"label":"heuristics","permalink":"/docs/tags/heuristics"},{"inline":true,"label":"games","permalink":"/docs/tags/games"},{"inline":true,"label":"pathfinding","permalink":"/docs/tags/pathfinding"}],"version":"current","frontMatter":{"title":"Search Algorithms in AI","id":"search-algorithms","tags":["ai-fundamentals","search","planning","heuristics","games","pathfinding"],"summary":"A detailed overview of uninformed and heuristic-based search strategies used in classical AI, with practical comparisons and use cases."},"sidebar":"tutorialSidebar","previous":{"title":"What is Narrow AI?","permalink":"/docs/topics/ai-fundamentals/narrow-ai"},"next":{"title":"Search Problem Summary","permalink":"/docs/topics/ai-fundamentals/search-problem"}}');var t=s(4848),i=s(8453);const a={title:"Search Algorithms in AI",id:"search-algorithms",tags:["ai-fundamentals","search","planning","heuristics","games","pathfinding"],summary:"A detailed overview of uninformed and heuristic-based search strategies used in classical AI, with practical comparisons and use cases."},l="\ud83e\udded Search Algorithms in AI",o={},h=[{value:"\ud83d\udd0d Uninformed Search Strategies",id:"-uninformed-search-strategies",level:2},{value:"\ud83c\udf0a Breadth-First Search (BFS)",id:"-breadth-first-search-bfs",level:3},{value:"\ud83c\udf0c Depth-First Search (DFS)",id:"-depth-first-search-dfs",level:3},{value:"\ud83d\udcca BFS vs DFS Comparison",id:"-bfs-vs-dfs-comparison",level:3},{value:"\ud83e\udde0 Heuristic (Informed) Search Strategies",id:"-heuristic-informed-search-strategies",level:2},{value:"\u26a1 Greedy Best-First Search",id:"-greedy-best-first-search",level:3},{value:"\ud83c\udf1f A* Search",id:"-a-search",level:3}];function c(e){const n={br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"-search-algorithms-in-ai",children:"\ud83e\udded Search Algorithms in AI"})}),"\n",(0,t.jsx)(n.p,{children:"This knowledge item covers foundational search algorithms used in classical AI. These algorithms guide intelligent agents in navigating problem spaces, finding optimal paths, or making strategic decisions in games."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"-uninformed-search-strategies",children:"\ud83d\udd0d Uninformed Search Strategies"}),"\n",(0,t.jsx)(n.p,{children:"These algorithms explore the search space without any domain-specific knowledge. They do not use heuristics and treat all paths equally."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"-breadth-first-search-bfs",children:"\ud83c\udf0a Breadth-First Search (BFS)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Strategy"}),": Explores the search tree level-by-level, starting at the root. It expands all nodes at a given depth before moving deeper."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Data Structure"}),": FIFO queue"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Optimal"}),": \u2705 Yes (if step costs are equal)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Complete"}),": \u2705 Yes"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Memory Usage"}),": \u274c High (stores all nodes at each level)"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use When"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["You want the ",(0,t.jsx)(n.strong,{children:"shortest-path solution"})]}),"\n",(0,t.jsxs)(n.li,{children:["The goal is ",(0,t.jsx)(n.strong,{children:"close to the root"})]}),"\n",(0,t.jsxs)(n.li,{children:["The tree is ",(0,t.jsx)(n.strong,{children:"not too deep"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Real-Life Analogy"}),":",(0,t.jsx)(n.br,{}),"\n","Navigating a city to find the nearest coffee shop \u2014 checking all the closest ones first."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"-depth-first-search-dfs",children:"\ud83c\udf0c Depth-First Search (DFS)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Strategy"}),": Explores as deep as possible along each branch before backtracking."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Data Structure"}),": LIFO stack (can be implemented recursively)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Optimal"}),": \u274c No"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Complete"}),": \u274c No (can get stuck in infinite paths)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Memory Usage"}),": \u2705 Low (only stores nodes on the current path)"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use When"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The solution is ",(0,t.jsx)(n.strong,{children:"likely deep"})]}),"\n",(0,t.jsxs)(n.li,{children:["You have ",(0,t.jsx)(n.strong,{children:"memory constraints"})]}),"\n",(0,t.jsxs)(n.li,{children:["You can tolerate ",(0,t.jsx)(n.strong,{children:"non-optimal answers"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Real-Life Analogy"}),":",(0,t.jsx)(n.br,{}),"\n","Exploring a maze by always turning left until hitting a wall, then backtracking."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"-bfs-vs-dfs-comparison",children:"\ud83d\udcca BFS vs DFS Comparison"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Feature"}),(0,t.jsx)(n.th,{children:"BFS"}),(0,t.jsx)(n.th,{children:"DFS"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Data Structure"}),(0,t.jsx)(n.td,{children:"Queue (FIFO)"}),(0,t.jsx)(n.td,{children:"Stack (LIFO)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Memory"}),(0,t.jsx)(n.td,{children:"High"}),(0,t.jsx)(n.td,{children:"Low"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Complete"}),(0,t.jsx)(n.td,{children:"\u2705 Yes"}),(0,t.jsx)(n.td,{children:"\u274c Not always"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Optimal"}),(0,t.jsx)(n.td,{children:"\u2705 Yes (equal cost)"}),(0,t.jsx)(n.td,{children:"\u274c No"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Best For"}),(0,t.jsx)(n.td,{children:"Shallow search"}),(0,t.jsx)(n.td,{children:"Deep solutions"})]})]})]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"-heuristic-informed-search-strategies",children:"\ud83e\udde0 Heuristic (Informed) Search Strategies"}),"\n",(0,t.jsx)(n.p,{children:"These use additional information (heuristics) to make better decisions about which path to explore next."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"-greedy-best-first-search",children:"\u26a1 Greedy Best-First Search"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Strategy"}),": Always selects the node that appears ",(0,t.jsx)(n.strong,{children:"closest to the goal"}),", based only on a heuristic function ",(0,t.jsx)(n.code,{children:"h(n)"}),"."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"f(n) = h(n)"})}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Data Structure"}),": Priority Queue"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Optimal"}),": \u274c No"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Complete"}),": \u274c No"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Fast?"})," \u2705 Yes, in large spaces"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Heuristic Example"}),":",(0,t.jsx)(n.br,{}),"\n","Straight-line distance from a city to the destination."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use When"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Speed matters more than correctness"}),"\n",(0,t.jsx)(n.li,{children:"The heuristic is generally reliable"}),"\n",(0,t.jsx)(n.li,{children:"The search space is vast (e.g., open-world maps)"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Drawbacks"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Easily ",(0,t.jsx)(n.strong,{children:"misled by poor heuristics"})]}),"\n",(0,t.jsxs)(n.li,{children:["May ",(0,t.jsx)(n.strong,{children:"miss shorter/cheaper paths"})]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"-a-search",children:"\ud83c\udf1f A* Search"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Strategy"}),": Balances actual cost (",(0,t.jsx)(n.code,{children:"g(n)"}),") and estimated cost to goal (",(0,t.jsx)(n.code,{children:"h(n)"}),") using:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"f(n) = g(n) + h(n)\r\n\r\n- **Optimal**: \u2705 Yes (if `h(n)` is admissible)\r\n- **Complete**: \u2705 Yes\r\n- **Data Structure**: Priority Queue\r\n\r\n**Use When**:\r\n\r\n- You want the **shortest or cheapest path**\r\n- You have a **good heuristic**\r\n- You're solving **maps, puzzles, or planning tasks**\r\n\r\n**Example**:\r\n\r\nFinding the shortest path from City A to City B, combining distance traveled (`g(n)`) and estimated distance left (`h(n)`).\r\n\r\n**Watch out**:\r\n\r\n- High memory usage in large graphs\r\n- Slows down with poor heuristics\r\n\r\n---\r\n\r\n### \ud83d\udd01 Summary Table\r\n\r\n| Algorithm | Uses Cost? | Uses Heuristic? | Optimal? | Complete? |\r\n| --- | --- | --- | --- | --- |\r\n| **BFS** | \u2705 Yes | \u274c No | \u2705 | \u2705 |\r\n| **DFS** | \u274c No | \u274c No | \u274c | \u274c |\r\n| **Greedy Best-First** | \u274c No | \u2705 Yes | \u274c | \u274c |\r\n| **A*** | \u2705 Yes | \u2705 Yes | \u2705 | \u2705 |\r\n\r\n---\r\n\r\n## \u265f\ufe0f Adversarial Search (Two-Player Games)\r\n\r\nUsed when the agent competes against another opponent.\r\n\r\n---\r\n\r\n### \ud83c\udfae Minimax Search\r\n\r\n**Strategy**: Simulates a turn-based game where one player tries to **maximize** score and the other tries to **minimize** it.\r\n\r\n- **Used In**: Chess, Checkers, Tic-Tac-Toe\r\n- **Assumes**: Perfect play from both players\r\n- **Optimal**: \u2705 Yes (for perfect information games)\r\n- **Problem**: Explores the full game tree = **exponential complexity**\r\n\r\n**Example**:\r\nYou're X in Tic-Tac-Toe. You simulate all your moves, all your opponent's responses, and choose the move that gives you the best worst-case scenario.\r\n\r\n---\r\n\r\n### \u2702\ufe0f Alpha-Beta Pruning\r\n\r\n**Improvement** over Minimax that **cuts off** parts of the tree that don't influence the final decision.\r\n\r\n- **Result**: Same outcome, much faster\r\n- **Tracks**:\r\n    - `\u03b1`: Best score that MAX can guarantee\r\n    - `\u03b2`: Best score that MIN can guarantee\r\n\r\n**Why it matters**:\r\n\r\n- Makes Minimax **scalable**\r\n- Can **double the depth** you can search in the same time\r\n\r\n---\r\n\r\n### \u23f3 Depth-Limited Minimax\r\n\r\n**Problem**: Real game trees (e.g. Chess) are too deep to search fully\r\n\r\n**Solution**: Set a depth limit and use an **evaluation function** to guess the value of non-terminal states\r\n\r\n**Example**:\r\nIn Chess:\r\n\r\n> \u201cWhite has a queen, black doesn\u2019t \u2192 score = +9\u201d\r\n> \r\n\r\n**Use When**:\r\n\r\n- Game trees are large\r\n- You need fast, *reasonably* good decisions (e.g. in real-time games)\r\n\r\n---\r\n\r\n## \ud83e\udde0 Takeaways\r\n\r\n- **BFS/DFS** are useful for exploring without prior knowledge\r\n- **Greedy and A*** use heuristics to improve speed or optimality\r\n- **Minimax and Alpha-Beta** are critical for game AI\r\n- Evaluation functions and pruning are key to real-time game performance\n"})})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>l});var r=s(6540);const t={},i=r.createContext(t);function a(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);